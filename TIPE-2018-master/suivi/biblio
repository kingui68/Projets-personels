L'informatique se donne notamment pour but d'exécuter des algorithmes de façon automatique. On aimerait pour cela pouvoir écrire les algorithmes dans un langage facilement compréhensible par l'homme. Malheureusement les machines pouvant exécuter des programmes ne comprennent qu'un seul type de langage, appelé pour cette raison langage machine. Il apparaît donc le besoin d'être capable de traduire les instructions d'un langage à un autre. [2] C'est exactement le rôle du compilateur : "un compilateur est un programme qui lit un programme écrit dans un premier langage – le langage source – et le traduit en un programme équivalent écrit dans un autre langage – le langage cible » [1].Bien qu'il puisse avoir d'autres utilités (comme la détection d'erreur dans un programme), c'est surtout son rôle de traducteur qui nous intéresse.

La compilation est un sujet déjà balisé bien qu'il soit toujours d'actualité, les informaticiens ayant déjà mis en évidence un processus-type et des méthodes pour la compilation. Ces méthodes sont décrites dans différents ouvrages [1,2]. Sa réalisation reste toutefois critique car un compilateur non optimisé peut rendre un programme très lent même s'il est lui-même bien écrit et optimisé. Pour reproduire au mieux ce processus théorique, nous avons dû nous renseigner sur les méthodes pratiques.

Pour cela, le choix des langages sur lesquels expérimenter s'est posé. La lecture de Structure et interprétation des programmes informatiques [1] nous a permis de nous familiariser avec le langage Scheme que nous avons donc pris pour langage source. Puis nous avons choisi Forth comme langage cible, parce qu'il s'agit d'un langage proche de la machine, et Caml Light pour programmer le compilateur en lui-même car utilisé dans de nombreuses sources, il est très adapté à la manipulation d'informations symboliques. Nous avons donc fréquemment consulté le manuel de Caml Light [4] et Le langage Caml de Xavier Leroy et Pierre Weiss [6] . Le langage Caml propose également deux outils, CamlLex et CamlYacc permettant de générer des programmes d'analyse lexicale et syntaxique du script source, étapes importantes de la compilation. Leur méthode d'utilisation est décrite dans Formation au langage Caml de Claude Marché et Ralf Treinen [3]. Lors de la réalisation pratique, nous nous sommes également aidé des cours de Jean-Christophe Filliâtre [7] et de ceux de Luc Maranget [5] qui détaillent comment écrire un compilateur avec Caml sans de tels outils.
